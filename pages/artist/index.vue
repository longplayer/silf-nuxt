<template>
  <div class="container">
    <h1 class="page-title" v-if="!tabTitle.length">{{ pageTitle }}</h1>
    <template v-else>
      <h2 class="sup-title">{{ pageTitle }}</h2>
      <h1 class="page-title">{{ tabTitle }}</h1>
    </template>

    <!-- use tabnav logic inside -->
    <div class="tab-nav" :class="tabClass + options.navDirection">
      <tab-nav-item
        :list="list"
        v-on:tabChanged="setActive"
        :class="'tab-' + options.navDirection"
      ></tab-nav-item>

      <!-- contents -->
      <!-- <template v-if="nested.isNestedContent">
        <transition name="fade" mode="out-in">
          <div class="tab-nav--contents nested-tab--container">
            <TabNav
              v-for="(tabnav, index) in nested.current"
              :key="index"
              :dataSource="tabnav"
            ></TabNav>
          </div>
        </transition>
      </template> -->

      <template v-if="activeItemIndex === 3">
        <transition name="fade" mode="out-in">
          <div class="tab-nav--contents nested-tab--container">
            <TabNav
              v-for="(tabnav, index) in tabSolo"
              :key="index"
              :dataSource="tabnav"
            ></TabNav>
          </div>
        </transition>
      </template>
      <template v-if="activeItemIndex === 4">
        <transition name="fade" mode="out-in">
          <div class="tab-nav--contents nested-tab--container">
            <TabNav
              v-for="(tabnav, index) in tabGroup"
              :key="index"
              :dataSource="tabnav"
            ></TabNav>
          </div>
        </transition>
      </template>

      <template v-else>
        <transition name="fade" mode="out-in">
          <component
            :is="'tab-nav-panel'"
            :data="list[activeItemIndex]"
            :class="'tab-' + options.navDirection"
            :key="activeItemIndex"
          ></component>
        </transition>
      </template>
    </div>
  </div>
</template>

<script>
const loadSlugPage = async (path, slugName, c) => {
  return await c
    .$content(path)
    .where({ slug: slugName })
    .fetch()
    .catch(err => {
      error({ statusCode: 404, message: "Page not found" });
    });
};
export default {
  async asyncData(context) {
    const page = await context.$content("artist").fetch();
    const solo1 = await loadSlugPage("/exhibs/solo", "solo-1", context);
    const solo2 = await loadSlugPage("/exhibs/solo", "solo-2", context);
    const group1 = await loadSlugPage("/exhibs/group", "group-1", context);
    const group2 = await loadSlugPage("/exhibs/group", "group-2", context);

    return {
      page,
      tabSolo: [solo1[0], solo2[0]],
      tabGroup: [group1[0], group2[0]]
    };
  },
  // const tabGroup = await context.$content("exhibs/group").fetch();
  data() {
    return {
      pageTitle: "The Artist",
      tabTitle: "",
      config: {
        navDirection: "v",
        defautTabIndex: 0
      },
      // tabnav data
      activeItemIndex: 0,
      tabClass: "tab-nav--",
      titleSelected: "",
      list: [],
      options: {},
      nested: {
        isNestedContent: false,
        current: [],
        solo: [],
        group: []
      }
    };
  },
  methods: {
    updateTitle(title) {
      this.tabTitle = title;
    },
    setActive(index) {
      this.activeItemIndex = index;
      this.titleSelected = this.list[this.activeItemIndex].title;
      this.nested.isNestedContent = false;

      if (index === 3 || index === 4) {
        // console.log(">>UPDATE NESTED TABS VALUES");
        this.nested.isNestedContent = true;
        this.nested.current = this.getActiveNestedTabNav(index);
        // console.log(this.nested);
      }
    },
    getActiveNestedTabNav(tabIndex) {
      switch (tabIndex) {
        case 3:
          return this.tabSolo;
        case 4:
          return this.tabGroup;
      }
    },
    createDataSource(data) {
      let res = [];
      data.tabs.forEach(tab => {
        tab.toc.forEach(item => {
          if (item.depth === 2) {
            res.push({
              id: item.id,
              title: item.text,
              content: tab // tab markup is generated by <nuxt-content>
            });
          }
        });
      });
      return res;
    }
  },
  mounted() {
    // 1 inverted items order from ASC to DESC
    this.tabSolo.reverse(); // reverse() method is desctructive, it changes the original array
    this.tabSolo.forEach(content => {
      content.tabs.reverse();
    });
    this.tabGroup.reverse(); // reverse() method is desctructive, it changes the original array
    this.tabGroup.forEach(content => {
      content.tabs.reverse();
    });
  },
  created() {
    // abord initialisation if tabnav is false
    if (this.page.hasOwnProperty("tabnav") && !this.page.tabnav) return;

    this.list = this.createDataSource(this.page);
    this.options = this.config;
    this.titleSelected = this.list[this.activeItemIndex].title;

    // const newArray = this.tabSolo.reverse();
    // 2. Optimize nested array process
    this.tabSolo.forEach(tabContent => {
      this.nested.solo.push(tabContent);
    });
    this.tabGroup.forEach(tabContent => {
      this.nested.group.push(tabContent);
    });
    this.nested.current = this.getActiveNestedTabNav(this.activeItemIndex);
  }
};
</script>

<style lang="postcss"></style>
